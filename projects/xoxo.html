<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <style>
    :root {
      --cell-size: 30em;
      /* width and height of container */
      --cell-border: calc(var(--cell-size) / 100);
      /* thickness of border between each cell */
      --o-icon-size: calc(var(--cell-size) / 5);
      /* overall size of o */
      --x-icon-size: calc(var(--o-icon-size) * 1.27);
      /* slant size of x, overall size should be roughly the same as o */
      --icon-border: calc(var(--o-icon-size) * 0.20);
      /* Thickness of x and o */
    }

    #board {
      display: grid;
      margin: 80px auto;
      width: var(--cell-size);
      height: var(--cell-size);
      grid-template-rows: 1fr 1fr 1fr;
      grid-template-columns: 1fr 1fr 1fr;
      /* border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 5px; */
    }

    /* Set outline for the board */
    .left {
      border-right: var(--cell-border) solid black;
    }

    .right {
      border-left: var(--cell-border) solid black;
    }

    .up {
      border-bottom: var(--cell-border) solid black;
    }

    .down {
      border-top: var(--cell-border) solid black;
    }

    /* formatting for each cell */
    .cells {
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    .cells>span {
      box-sizing: border-box;
    }

    /* 
        styling for x 
        To make an "X", make a "+" within the element..
        .. and rotate the element by 45 degrees.
        This is the best method I came up with, and is consistent with every size ;)
        */
    .x {
      display: block;
      position: relative;
      height: var(--x-icon-size);
      width: var(--x-icon-size);
      transform: rotate(45deg);
    }

    .x::before,
    .x::after {
      position: absolute;
      content: "";
      background-color: black;
      border-radius: calc(var(--icon-border) / 4);
    }

    .x::after {
      height: var(--x-icon-size);
      width: var(--icon-border);
      right: calc(calc(var(--x-icon-size) / 2) - calc(var(--icon-border)/2));
    }

    .x::before {
      width: var(--x-icon-size);
      height: var(--icon-border);
      top: calc(calc(var(--x-icon-size) / 2) - calc(var(--icon-border)/2));
    }

    /* styling for o */
    .o {
      display: block;
      height: var(--o-icon-size);
      width: var(--o-icon-size);
      border: var(--icon-border) solid black;
      border-radius: 50%;
    }

    /* stats */
    #panel {
      width: var(--cell-size);
      display: flex;
      margin: 2em auto;
      justify-content: space-evenly;
    }

    .statvalue {
      font-family: monospace;
      font-size: 3em;
    }

    .statkey {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      text-transform: uppercase;
    }

    .stats {
      display: flex;
      flex-direction: column;
      flex-basis: calc(var(--cell-size) / 4);
      text-align: center;
    }
  </style>

</head>

<body>
  <div>
    <div id="board">
      <span class="cells left up">
        <span id="one"></span>
      </span>
      <span class="cells up">
        <span id="two"></span>
      </span>
      <span class="cells right up">
        <span id="three"></span>
      </span>
      <span class="cells left ">
        <span id="four"></span>
      </span>
      <span class="cells ">
        <span id="five"></span>
      </span>
      <span class="cells right ">
        <span id="six"></span>
      </span>
      <span class="cells left down">
        <span id="seven"></span>
      </span>
      <span class="cells down">
        <span id="eight"></span>
      </span>
      <span class="cells right down">
        <span id="nine"></span>
      </span>
    </div>
    <div id="panel">
      <span class="stats">
        <span class="statkey">Player</span>
        <span id="player" class="statvalue">0</span>
      </span>
      <span class="stats">
        <span class="statkey">Draws</span>
        <span id="draw" class="statvalue">0</span>
      </span>
      <span class="stats">
        <span class="statkey">Computer</span>
        <span id="computer" class="statvalue">0</span>
      </span>
    </div>
  </div>

  <script>
    class Utility
    {
      static drawDom = document.getElementById("draw")
      static computerDom = document.getElementById("computer")
      static playerDom = document.getElementById("player")

      static cellDictionary = {
        "one": 1, "two": 2, "three": 3, "four": 4, "five": 5, "six": 6, "seven": 7, "eight": 8, "nine": 9
      }

      static cellNodes = Array
        .from(document.getElementById("board").children)
        .filter(each => each.classList.contains("cells"))
        .map(each => each.firstElementChild)
        .sort((a, b) => Utility.cellDictionary[a] > Utility.cellDictionary[b] ? 1 : -1) // make sure the cells are in correct order. Would be important for checking if there's a winner

      static checkWin  = (arr, type) => arr[0].contains(type) && arr[1].contains(type) && arr[2].contains(type)
      static checkFull = (arr) => Utility.checkWin(arr, "x") || Utility.checkWin(arr, "o")

      static pickThreeHorizontal = (arr, start) => Utility.pickThreeWithStep(arr, start, 1)
      static pickThreeVertical   = (arr, start) => Utility.pickThreeWithStep(arr, start, 3)

      static pickThreeWithStep = (arr, start = 0, step = 1) => {
        let tmp = []
        for (let i = start; tmp.length < 3 && i < arr.length; i += step) {
          tmp.push(arr[i])
        }
        return tmp
      }

      static isThereWinner = () => {
        const nodes = Utility.cellNodes.map(each => each.classList)
        // first horizontal
        if (Utility.checkFull(Utility.pickThreeHorizontal(nodes, 0)))
          return true
        // second horizontal
        if (Utility.checkFull(Utility.pickThreeHorizontal(nodes, 3)))
          return true
        // third horizontal
        if (Utility.checkFull(Utility.pickThreeHorizontal(nodes, 6)))
          return true
        // first vertical
        if (Utility.checkFull(Utility.pickThreeVertical(nodes, 0)))
          return true
        // second vertical
        if (Utility.checkFull(Utility.pickThreeVertical(nodes, 1)))
          return true
        // third vertical
        if (Utility.checkFull(Utility.pickThreeVertical(nodes, 2)))
          return true
        // first diag
        if (Utility.checkFull([nodes[0], nodes[4], nodes[8]]))
          return true
        // second diag
        if (Utility.checkFull([nodes[2], nodes[4], nodes[6]]))
          return true
        return false
      }

      static isThereStalemate = () => {
        return Utility.cellNodes
          .map(each => each.classList)
          .filter(each => !(each.contains("x") || each.contains("o")))
          .length <= 0
          && !Utility.isThereWinner()
      }

      static isGameOver() {
        return Utility.isThereWinner() || Utility.isThereStalemate()
      }

      static incrementDom(domNode){
        return parseInt(domNode.innerHTML) + 1
      }

      static resetState(ai) {
        const cellClasses = Utility.cellNodes
          .map(each => each.classList)

        cellClasses
          .forEach(each => {
            if (each.contains("x"))
              each.remove("x")
            if (each.contains("o"))
              each.remove("o")
          })

        ai.reset()
      }
    }

    class Computer
    {
      static allIds = ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]

      constructor() {
        this.reset()
      }

      reset() {
        this.freeSpaces = Computer.allIds.slice()
      }

      playMove(playersMove) {
        const deleteMove = (moves, target) => moves.filter(each => each !== target)

        if (!this.freeSpaces.includes(playersMove)) throw "players move not found"
        this.freeSpaces = deleteMove(this.freeSpaces, playersMove) // removes players move from available moves

        let nextMoveId = Math.floor(Math.random() * this.freeSpaces.length)
        let nextMove = this.freeSpaces[nextMoveId]
        this.freeSpaces = deleteMove(this.freeSpaces, nextMove)  // removes computers move from available moves

        return nextMove
      }

      canStillPlay() {
        return !Utility.isGameOver() && this.freeSpaces.length > 1
      }

    }

    class Game
    {
      constructor(playerisx=true) {
        this.xToPlay = playerisx
        this.playerIsX = playerisx
      }

      switchPlayer(){
        this.xToPlay = !this.xToPlay
      }

      getNextPlayer() {
        let nextPlayer = this.xToPlay ? "x" : "o"
        this.switchPlayer()
        return nextPlayer
      }

      getIdOfWinner(winnerIsX){
        return winnerIsX ^ this.playerIsX ? "player" : "computer"
      }

      getDomOfWinner(winnerId){
        switch(winnerId){
          case "player"  : return Utility.playerDom
          case "computer": return Utility.computerDom
          default: throw "error"
        }
      }

      renderMove(node, moveType) {
        node.classList.add(moveType)
        if (Utility.isThereStalemate()) {
          Utility.drawDom.innerHTML = Utility.incrementDom(Utility.drawDom)
        }
        if (Utility.isThereWinner()) {
          const winner = this.getIdOfWinner(this.xToPlay)
          const winnerDom = this.getDomOfWinner(winner)
          winnerDom.innerHTML = Utility.incrementDom(winnerDom)
            /* fix bug when computers play changes from original when it loses */
          if (winner==="player")
            this.switchPlayer()
        }
      }
    }

    function getValidCellsOnEvent(event) {
      let sourceNode = event.target
      // filter when cells arent clicked
      if (!sourceNode.classList.contains("cells")) return null;

      let childNode = sourceNode.firstElementChild
      // filter when an invalid child node is clicked
      if (!childNode) throw "error"
      if (childNode.classList.contains("x") || childNode.classList.contains("o")) return null// move has already been played

      return childNode
    }

    const ai = new Computer()
    const game = new Game(false)
    // const util = new Utility()

    document.addEventListener("mousedown", event => {
      if (Utility.isGameOver()) {
        Utility.resetState(ai)
      }
      else {
        let childNode = getValidCellsOnEvent(event)
        if (!childNode) return

        // childNode.classList.add( getNextPlayer() )
        game.renderMove(childNode, game.getNextPlayer())

        if (ai.canStillPlay()) {
          const playersMove = childNode.id
          const aiMove = ai.playMove(playersMove)
          let targetNode = document.getElementById(aiMove)
          game.renderMove(targetNode, game.getNextPlayer())
        }
      }
    })
  </script>
</body>
</html>